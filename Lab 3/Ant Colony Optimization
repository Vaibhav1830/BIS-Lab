import math, random

nodes = list(range(8))
edges = {
    0: {1: 2, 2: 5},
    1: {0: 2, 2: 3, 3: 4},
    2: {0: 5, 1: 3, 4: 6},
    3: {1: 4, 4: 2, 5: 7},
    4: {2: 6, 3: 2, 5: 1, 6: 5},
    5: {3: 7, 4: 1, 6: 3, 7: 8},
    6: {4: 5, 5: 3, 7: 2},
    7: {5: 8, 6: 2}
}
 
n = len(nodes)
source = 0
destination = 7

m = 10
alpha = 1
beta = 3
rho = 0.2
tau0 = 1.0
iterations = 20
Q = 100

tau = [[0.0]*n for _ in range(n)]
for i in edges:
    for j in edges[i]:
        tau[i][j] = tau0

eta = [[0.0]*n for _ in range(n)]
for i in edges:
    for j,w in edges[i].items():
        eta[i][j] = 1.0/w

best_length = float("inf")
best_path = None

def construct_path():
    start = source
    path = [start]
    visited = set([start])
    current = start
    max_steps = n*5
    steps = 0
    while current != destination and steps < max_steps:
        neighs = list(edges[current].keys())
        unvisited = [j for j in neighs if j not in visited]
        candidates = unvisited if unvisited else neighs
        probs = []
        denom = sum((tau[current][j]**alpha) * (eta[current][j]**beta) for j in candidates)
        if denom == 0:
            j = random.choice(candidates)
            path.append(j)
            visited.add(j)
            current = j
            steps += 1
            continue
        for j in candidates:
            pij = (tau[current][j]**alpha) * (eta[current][j]**beta) / denom
            probs.append((j,pij))
        r = random.random()
        cum = 0
        chosen = probs[-1][0]
        for j,p in probs:
            cum += p
            if r <= cum:
                chosen = j
                break
        path.append(chosen)
        visited.add(chosen)
        current = chosen
        steps += 1
    if current != destination:
        return None, float("inf")
    length = 0.0
    for i in range(len(path)-1):
        a,b = path[i], path[i+1]
        length += edges[a][b]
    return path, length

for it in range(iterations):
    all_paths = []
    all_lengths = []
    for k in range(m):
        path, length = construct_path()
        all_paths.append(path)
        all_lengths.append(length)
        if length < best_length:
            best_length = length
            best_path = path
    for i in range(n):
        for j in range(n):
            if tau[i][j] > 0:
                tau[i][j] *= (1 - rho)
    for k in range(m):
        path = all_paths[k]
        Lk = all_lengths[k]
        if path is None or Lk == float("inf"):
            continue
        deposit = Q / Lk
        for i in range(len(path)-1):
            a,b = path[i], path[i+1]
            tau[a][b] += deposit
            tau[b][a] += deposit
    if best_path:
        print(f"Iteration {it+1}: Best Length so far = {best_length:.2f} Path = {best_path}")
    else:
        print(f"Iteration {it+1}: No valid path found yet")

print("\nFinal Best Path:", best_path)
print("Final Best Length:", best_length)


